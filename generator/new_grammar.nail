#define t(x) {WHITE;many uint8 = x}
#define lower  (uint8 |  'a'..'z')
#define upper (uint8 |  'A'..'Z') 
#define digit  (uint8 | '0' .. '9')
number = many1 digit
varidentifier   = <WHITE; many1 lower>
constidentifier = <WHITE; many1 upper>
contextidentifier = <WHITE uint8='@'; many1 lower>
WHITE = many || uint8 = ' ' || uint8 = '\n'
SEPERATOR = {many uint8=' '; many || uint8 = '\n' || uint8 = ';'}
intconstant = <WHITE;  choose {
            ASCII= <uint8 = '\''
                   choose{
                     ESCAPE= <uint8 = '\\'; uint8>
                     DIRECT= uint8
                    } 
                     uint8 = '\''>
            NUMBER= number
            }>

intp = choose{
          UNSIGNED = < t("uint")
                      many1 digit>
          SIGNED =   < t("int")
                      many1 uint8 | '0' .. '9'>
}  
constint = { parser intp
             t("=")
             value intconstant }
arrayvalue = choose {  // We could use a push-choose operator here.... 
           STRING= < WHITE uint8 = '"' many uint8 | !['"'] uint8 = '"' > 
           VALUES= < t("[") many intconstant t("]")> 
           }    
constarray = { t("many ");parser intp;  t("="); value arrayvalue}
constfields = sepBy1 SEPERATOR constparser
constparser = choose{   
            CARRAY=            constarray
            CREPEAT=           <t("many ") *constparser>
            CINT=              constint
            CREF=              constidentifier
            CSTRUCT =          < t("{"); constfields ;t("}")>
            CUNION = many1 <t("||") constparser>
}         
intconstraint  = choose {
               RANGE = { min optional intconstant; t(".."); max optional intconstant}
               SET = < t("[");  sepBy1 uint8 = ','  intconstant ; t("]") >
               NEGATE = < t("!") *intconstraint>
               }
constrainedint = {
                parser intp
                constraint optional <t("|")  intconstraint  >  
}

structparser = <t("{"); sepBy SEPERATOR choose{
              CONSTANT = constparser                      
              CONTEXT = {name contextidentifier; parser constrainedint}    
              FIELD= { name varidentifier;  parser *parser }

              } 
         t("}")>
wrapparser = {t("<"); constbefore optional <sepBy1 SEPERATOR constparser; SEPERATOR>
                      parser *parser
                      constafter optional <SEPERATOR;sepBy SEPERATOR constparser>
                      t(">") }
// choiceidentifier = || varidentifier || constidentifier                      
choiceparser = < t("choose"); t("{"); many {tag  constidentifier; t("="); parser  *parser }; t("}") >
arrayparser =   choose{         
                MANYONE= < t("many1"); *parser>
                MANY=  < t("many"); *parser>  
                SEPBYONE={ t("sepBy1"); separator constparser; inner *parser}    
                SEPBY= { t("sepBy") ; separator constparser; inner *parser}
                }

parserinner =  choose {// because we don't do left recursive grammars yet
                INT= constrainedint
                STRUCT= structparser
                WRAP = wrapparser
                CHOICE= choiceparser
                ARRAY = arrayparser
                LENGTH = <t("n_of") { length contextidentifier; parser *parser}>
                OPTIONAL= <t("optional ") *parser>
                UNION = many1 <t("||") *parser>
                REF   =  <t("*") varidentifier >
                NAME  =  varidentifier
         } // replace with a proper wrap
parser = choose {PAREN=<t("(") parserinner t(")")>
                 PR= parserinner}
definition = choose {
           PARSER = {name  varidentifier
                    t("=")
                    definition parser }
           CONST = {
                 name constidentifier 
                 WHITE
                 uint8 = '='
                 WHITE 
                 definition constparser
           }          
           }
grammar = <many1 definition; WHITE>