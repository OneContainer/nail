#define t(x) {WHITE;many uint8 = x}
#define lower  (uint8 |  'a'..'z')
#define upper (uint8 |  'A'..'Z') 
#define digit  (uint8 | '0' .. '9')
number = many1 digit
varidentifier   = <WHITE; many1 lower>
constidentifier = <WHITE; many1 upper>
WHITE = many uint8 = ' ' || uint8 = '\n'
SEPERATOR = many uint8 = '\n' || uint8 = ';'
intconstant = <WHITE;  choose {
            ASCII= <uint8 = '\''
                   choose{
                     escape= <uint8 = '\\'; uint8>
                     direct= uint8
                    } 
                     uint8 = '\''>
            NUMBER= number
            }>

intp = choose{
          UNSIGNED = { t("uint")
                       length  many1 digit}
          SIGNED =   { t("int")
                       length many1 uint8 | '0' .. '9'}
}  
constint = { parser intp
             t("=")
             value intconstant }arrayvalue = choose {  // We could use a push-choose operator here.... 
           STRING= < WHITE uint8 = '"' many uint8 | !['"'] uint8 = '"' > 
           VALUES= < t("[") many intconstant t("]")> 
           }    
constarray = { t("many");parser intp;  t("="); value arrayvalue}
constfield = choose{   
            CARRAY=            constarray
            CINT=              constint
            CREF=              constidentifier
}         
intconstraint  = choose {
               RANGE = { min optional intconstant; t(".."); max optional intconstant}
               SET = < t("[");  sepBy1 uint8 = ','  intconstant ; t("]") >
               NEGATE = < t("!") *intconstraint>
               }
constrainedint = {
                parser intp
                constraint optional <t("|")  intconstraint  >  
}

structparser = <t("{"); sepBy SEPERATOR choose{
              constant = constfield                      
              field= { name varidentifier;  parser *parser }
              } 
         t("}")>
wrapparser = {t("<"); const_before optional <sepBy1 SEPERATOR constfield; SEPERATOR>
                      parser *parser
                      const_after sepBy SEPERATOR constfield
                      t(">") }
                      
choiceparser = < t("choose"); t("{"); many {tag varidentifier; t("="); parser  *parser }; t("}") >
arrayparser =   choose{         
                MANYONE= < t("many1"); *parser>
                MANY=  < t("many"); *parser>  
                SEPBYONE={ t("sepBy1"); seperator *parser; inner *parser}    
                SEPBY= { t("sepBy") ; seperator *parser; inner *parser}
                }

parserinner =  choose {// because we don't do left recursive grammars yet
                INT= constrainedint
                STRUCT= structparser
                WRAP = wrapparser
                CHOICE= choiceparser
                ARRAY = arrayparser
                OPTIONAL= <t("optional") *parser>
                UNION = many1 <t("||") *parser>
                REF   =  <t("*") varidentifier >
                NAME  =  varidentifier
         } // replace with a proper wrap
parser = choose {PAREN=<t("(") parserinner t(")")>
                 PR= parserinner}
definition = choose {
           PARSER = {name  varidentifier
                     WHITE
                     uint8 = '='
                     WHITE
                     definition parser }
           CONST = {
                 name constidentifier 
                 WHITE
                 uint8 = '='
                 WHITE 
                 definition parser 
           }          
           }
grammar = many definition