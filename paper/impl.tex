\section{Implementation}
The current prototype of the Nail parser generator supports the C programming language and top down parsers. Options for C++ STL data models and emitting Packrat parser
\cite{packrat-parsing:icfp02} are under heavy development. In this section, we will discuss some particular
features of our parser implementation.

\paragraph{Parsing}
A generated Nail parser makes two passes through the input , the first to validate and recognise the
input, the second to bind this data to the internal model. Currently the parser is a straightforward
top down parser, although facilities have been made to add Packrat parsing to achieve linear parsing times.
\paragraph{Memory allocation} 
Many security vulnerabilities can occur when heap allocations are done improperly. Therefore, just
like Hammer, Nail avoids using the heap as much as possible, using a custom arena allocator and
allocating only fixed size blocks from the system malloc. However, Nail extends upon Hammers
approach and uses two arenas for each parsed input. One arena is used for intermediate results and is
freed(and zeroed) after parsing completes, whereas the other arena is used only for allocating the
result and has to be freed by the programmer. 

\paragraph{Intermediate representation}
Most parser generators, such as Bison do not have to dynamically allocate temporary
data, as they evaluate a semantic action on every rule. However, as our goal is to perform as little
computation as possible without having validated the input, and we do not want to mix temporary
objects with the results of our parse, we need some intermediate structure to cache parse results.
This structure is also used as a value in the Packrat hash table. 

Hammer solves this problem by storing a full abstract syntax tree. However, this abstract syntax
tree is at least an order of magnitude larger than the input, because it stores a large tree node
structure for each input byte and for each rule reduced. This allows Hammer semantic actions to get
all necessary information without ever seeing the raw input stream. However, because we also
automatically generate our second pass, which corresponds to Hammers semantic actions, we can trust
it as much as we trust the parser and thus expose it to the raw input stream. 

Under this premise, the actions need very limited information from the recogniser to correctly
handle the input stream. In particular, the parsers control flow only branches at the choice and
repeat combinators. For all other combinators, the action just has to assign a fixed sequence of
fundamental parsers to a fixed sequence of internal model fields. 
Thus we can represent the parsers success as a sequence of selected choices and counted repeats and
use this to reconstruct the syntax of the input. %TODO: This sentence is HORRIBLE. Re-work 
\paragraph{Dependency Fields}
During parsing, dependency fields occur before the context in which they are used. The parser stores
their value and retrieves it afterwards when encountering the combinator that uses them. When
generating output, the dependency field is first filled with a filler value, then later when the
first combinator that determines this fields value is encountered, the field is overwritten. Any
further combinators using this dependency will then validate that the dependency field is correct. 
\paragraph{Bootstrapping}
To demonstrate the feasibility of the nail parser generator, our parser generator uses a Nail parser
to recognise Nail grammars. A superset of the grammar language described in this paper is
implemented in 100 lines of Nail, which feed into about a thousand lines of C++ that implement the
actual parser generator. Bootstrapping is supported via an LALR implementation.
