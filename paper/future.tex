\section{Future Work}

The Nail parser generator is work in progress and feedback of all sorts is heavily
encouraged. Source code is available upon request and will be released publicly pending clean-up and
maturity. Short-term future work will include improving the scoping of dependency fields and adding
support for offset fields.

A major problem with the current design of Nail is that the design of the grammar dictates the
interna structure of the software. This makes changing grammars or adding Nail to existing software
awkward. One possible solution to this problem would be to implement a concept similar to Relational
Lenses \cite{bohannon2006relational}, which would allow  the data model to be 'seen' by
the rest of the program through an isomorphism. Such an isomorphism would still be much more concise
than two sets of semantic actions, while allowing changes in syntax, alternative representations
and adaption to legacy systems.

Finally, we would like to demonstrate the capabilities of Nail by implementing various binary
formats 'notorious' for their insecurity in Nail. Nail was designed with the idioms of formats such
as PDF and PNG in mind. Ultimately, we want to provide examples of successful Nail parsers all
throughout a network stack - from a user-space TCP stack to a PNG de-compressor.

\subsection{Previous work}
Generating parsers and generators from an executable specification is the core concept of Interface
Generators, e.g. in CORBA or more recently\cite{varda2008}. However, while interface
generators work very well for existing grammars, they do not allow full control over the format of
the output, so cannot be used to implement legacy protocols.
Very related work has been done at Bell Labs with the PacketTypes system\cite{mccann2000packet},
however PacketTypes works only as a parser and does not support the expressive power of PEGs, but rather
implements a C like structure model enhanced with data-dependent length fields and constraints.
\begin{comment}

Memory corruption exploits (frequently) rely on placing controlled values at known (or controlled)
memory locations. Exploit countermeasures  like Address-Space Layout Randomisation\cite{pax-aslr},
 heap cookies \cite{heapcookies} or data execution prevention try to make this harder for
 an attacker. Attackers have developed techniques such as heap spraying \cite{heapspray} and heap
 feng shui\cite{fengshui} to help bypass those mitigations. 


Nail parsers use two arena allocators\cite{arena}, one for the temporary syntax tree and one for the
result. If Nail were to use the normal system allocator, the attacker could cause two packets to be
parsed at the same time (or, given a sufficiently complicated input, two structure within the same
grammar to be parsed sequentially) such that the (invalid) intermediate results from one parse,  
 If there is a buffer overflow past the
end of one input, it is much harder for the attacker craft a sequence of packets to trick the allocator into
placing a known value next to that input.

\end{comment}
