\section{Design By Example}
In this section, we will explain how to handle basic data formats in Nail, how to handle
redundancies in the format with dependent fields and how Nail parsers can be extended with
transformations. 

We will use DNS packets as a leading example, as defined in RFC 1035~\cite[\S4]{RFC:1035}.  Each DNS packet consists of a
header, a set of question records, and a set of answer records. Domain
names in both queries and answers are encoded as a sequence of labels,
terminated by a zero byte.  Labels are Pascal-style strings, consisting
of a length field followed by that many bytes comprising the label.
\label{s:design}
\subsection{Basic Data formats}

\input{fig-dnsfull}
Let's stepping through a simplified Nail grammar for non-compressed
packets, shown in  Figure~\ref{fig:dns-full}.  For this grammar, Nail produces the type declarations
shown in Figure~\ref{fig:dns-full-struct}, and the parser and
generator functions shown in Figure~\ref{fig:dns-full-api}.
Nail grammars are reuseable between applications and we will use this grammar to implement
both a DNS server and client, which previously would have had two separate hand-written parsers,
leading to bugs such as  the Android Master Key. 

A Nail grammar file consists of rule definitions, for example l. 1-20,  which assign a name
(\texttt{dnspacket}) to a grammar production (2-20). If you are not familiar with
other parsers, you can imagine rules as C type declarations on steroids
(although our syntax is inspired by Go).

Just like C supports various constructs to build up types, such as structures, unions, pointers and
elemental types, Nail supports a integers as elemental parsers and a plethora of \emph{combinators}
to represent features of a file or protocol. We will present the features we used in implementing
DNS. A more complete reference can be found in~\ref{fig:syntax}, with detailed rationale in~\cite{bangert:nail-osdi14}.



\paragraph{Integers and Constraints}.
Because Nail is designed to cope with binary formats,
it handles not only common integer types (such as \texttt{uint16} on l. 16), but bit fields of any
length, such as \texttt{uint1}. These integers are exposed to the programmer as an appropriately
sized machine integer, e.g. \texttt{uint8\_t}. Nail also supports constraints on integer values,
limiting the values to either a range (l. 23, \texttt{|1..16}), which can optionally be half-open,
or a fixed set (l. 24, \texttt{|[1,255]}). Both types of constraint can be combined, e.g. \texttt{|
  [1..16,255]}. Constant values are also supported, e.g. l. 10: \texttt{uint3=0} represents
three reserved bits that must be 0. Because constant values carry no information, they are not
represented in the data type.

\paragraph{Structures.}

The body of the \texttt{dnspacket} rule is a structure, which contains any number of fields enclosed
between  curly braces. Each field in the structure is parsed in sequence, and represented as a
structure to the programmer.  Contrary to other programming languages, Nail does not have a special
keyword for structs. We also reverse the usual structure-field syntax: \texttt{id uint1} is a field
called \texttt{id} with type \texttt{uint1}\footnote{This is a feature from Go, and makes nested
  types more readable and the parser for Nail itself easier to write.}. Often, Nail grammars have
structures with just one non-constant field, for example when parsing a fixed header. To prevent
this from cluttering the data type, we support an alternative form of the structure combinator,
using angle brackets, that has just one unnamed, non-constant field, which is represented directly
in the data type. 

% To support recursive structures, we include a reference combinator \cc{*}, which
%   is syntactically equivalent to directly including the parser, but in the internal model adds a
%   level of indirection to the value. This allows recursive structures to be parsed, f

\input{fig-syntax}

\subsection{Redundant Data}
\label{s:dependent}
Data formats often contain values that are determined by other values or the layout of information,
such as checksums, duplicated information, or offset and  length fields. Exposing such values risks
inconsistencies that could trick the program into unsafe behaviour. Therefore, we represent such values using \emph{dependent fields} and handle them transparently during
parsing and generation without exposing them to the application. 
Dependent fields are handled like other fields when parsing input, but only stored temporarily
instead of in the data type. Their value can be referenced by other parsers until it goes out of scope.
When generating output, Nail inserts the correct value.

In DNS packets, the packet header contains count fields (\cc{qc},
\cc{ac}, \cc{ns}, and \cc{ar}), which contain the number of questions and answers that follow the
header, which we represent by dependent fields (line 12-15).
Dependent fields are defined within a structure like normal fields, but their name starts with an \cc{@} symbol.
A dependent field is in scope and can be referred to by the definition of all subsequent fields in
the same structure. Dependent fields can be passed to rule invocations as parameters.

Nail provides only one built-in combinator that uses dependent fields, \cc{n_of}, which acts like
the \cc{many} combinator, except it parses an exact number of repetitions specified in the dependent
field. Lines 16-19 in Figure~\ref{fig:dns-full} shows how to use \cc{n_of} to parse the question and
answer records in a DNS packet.
Other dependencies, such as offset fields or checksums, are not handled directly by combinators, but
through  transformations, as we describe next.

\subsection{Input streams and transformations}
\label{s:transforms}

Traditional parsers handle input one symbol at a time, from beginning to end.
However, real-world formats often require non-linear parsing. Offset fields require a parser to move
to a different position in the input, possibly backwards. Size fields require the parser to stop
processing before the end of input has been reached, and perhaps resume executing a parent parser.
Other cases, such as compressed data, require more complicated processing on parts of the input
before it can be handled.

Nail introduces two concepts to handle these challenges, \emph{streams} and \emph{transformations}. 
Streams represent a sequence of bytes that contain some external format. The parsers and generators
that Nail generates always operate on an implicit stream named \cc{\$current} that they process front to
back, reading input or appending output.
Grammars can use the \cc{apply} combinator to parse a stream or generate output into it. 

Streams are passed as arguments to a rule or defined within the grammar through \emph{transformations}.
The current stream is always passed as an implicit parameter.

Transformations are two arbitrary functions called during parsing and output generation.
The parsing function  takes any number of stream arguments and dependent field values,
and produces any number of temporary streams. This function may reposition and read from the
input streams and read the values of dependent fields, but not change their contents and values. 
The generating function has to be an inverse of the parsing function. It takes the same number of
temporary streams that the parsing function produces, and writes the same number of streams and
dependent field values that the parsing function consumes.

Typically, the top level of most grammars is a rule that takes only a single stream, which may then
be broken up by various transformations and passed to sub-rules, which eventually parse various linear
fragment streams. Upon parsing, these fragment streams are generated and then combined by the
transforms.

 To reduce both programmer effort and the risk of unsafe operations, Nails provides implementations of
transformations for many common features, such as checksums, size, and offset fields. Furthermore,
Nail provides library functions that can be used to safely operate on streams, such as splitting and
concatenation. Nail implements streams as iterators, so they can share underlying buffers and can be
efficiently duplicated and split.

Transformations need to be carefully written, because they can violate Nail's safety properties
and introduce
bugs. However, as we will show in \S\ref{s:eval-effort}, Nail transformations are much shorter than
hand-written parsers, and many formats can be represented with just the transformations in Nail's
standard library.
For example, our Zip transformations are 78 lines of code, compared to 1600 lines of code for a
   hand-written parser. Additionally, Nail provides convenient and safe interfaces for allocating
   memory and accessing streams that address the most common occurrences of buffer overflow
   vulnerabilities.  

Transformations can handle a wide variety of patterns in data formats, including the following: 

\paragraph{Compressed data.}
Encoded, compressed, or encrypted data can be handled transparently by writing a custom
transformation that transforms a coded stream into one that can be parsed by a Nail grammar and vice
versa. This transformation must be carefully written to not have bugs. 

For example, DNS uses label compression to reduce the overhead of including each domain name
multiple times in a DNS reply. If a domain name suffix is repeated, it may be replaced by a two-bit
marker followed by a  14-bit offset into the packet, indicating the position where that suffix was
previously encoded.  We use a transform in line 35
of our DNS grammar to handle DNS label compression; the signatures of the two transform functions are shown
in Figure~\ref{fig:dns-xform}.  When parsing a packet, this transform
decompresses the DNS label stream.
When generating a packet, this transform receives the current suffix as
an input, and scans the packet so far for previous occurrences and inserts the offset.

\begin{figure}
\smaller[0.5]
\input{code/dns-xform}
\caption{Signatures of stream transform functions for handling DNS label compression.}
\label{fig:dns-xform}
\end{figure}
Handling label compression in existing tools, such as Bison or Hammer,
would be awkward at best, because some ad-hoc trick would have to
be used to re-position the parser's input stream.  Keeping track of the
position of all recognized labels would not be enough, although still awkward, as the offset field
may refer to any byte within the packet.
For this reason, the sample DNS grammar in Hammer does not
support compression.

\paragraph{Offsets.}
A built-in transformation for handling offset fields, which is invoked as follows:
\cc{\$fragment transform offset\_u32(\$current, \cc{@}offset)}. 
This transformation corresponds to two functions for parsing and
generation, as shown in Figure~\ref{fig:xform-sig}. It defines a new stream \cc{\$fragment} that can
be used to parse data at the offset contained in \cc{@offset}, by
using \cc{apply \$fragment some_parser}.



\begin{figure}[h]
\smaller[0.5]
\input{code/offset-xform}
\caption{Pseudocode for two functions that implement the offset transform.}
\label{fig:xform-sig}
\end{figure}

\paragraph{Sizes.}
A similar transformation handles size fields. Just like the offset transform, it takes two parameters, a
stream and a dependent field, but instead of returning the suffix of the current stream after an
offset, it returns a slice of the given size from the current stream starting at its current
position. When generating, it appends the fragment stream to the current stream and writes the size
of the fragment to the dependent field.

\paragraph{Checksums.}
Checksums can be verified and computed in a transformation that takes a stream and a dependent
field. In some cases, a checksum is calculated over a buffer that contains the checksum itself, with
the checksum being set to some particular value. 

\paragraph{}
A real-world example with many different transforms, used to support
the ZIP file format, is described in our full paper.%\S\ref{s:eval-formats}.


% For example, we imagine the following grammar could be used to represent
% a sequence of bytes \texttt{data} followed by its CRC32 checksum:

% \begin{verbatim}
% data many uint8; @checksum uint32
% raw_depend @checksum data crc32
% \end{verbatim}

% \noindent
% where \texttt{crc32} is a function supplied by the application, with
% the following signature:

% \begin{verbatim}
% bool crc32(uint32_t *out, uint8_t *in);
% \end{verbatim}

% Because this feature compromises Nail's security guarantees, it should
% only be used in limited circumstances and with carefully prepared checksum
% functions.  This feature is not implemented in the current prototype.

