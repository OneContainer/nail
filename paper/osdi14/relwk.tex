\section{Related work}
\label{s:relwk}

\paragraph{Parsers.}

Generating parsers and generators from an executable specification is the
core concept of interface generators, such as CORBA~\cite{omg:corba},
XDR~\cite{rfc:1832}, or Protocol Buffers~\cite{varda2008}.  However,
while interface generators work well for defining new protocols, they
do not provide full control over the data format, and therefore cannot
be used to implement existing protocols and data formats.

Closely related work has been done at Bell Labs with the PacketTypes
system~\cite{mccann2000packet}.  However, PacketTypes works only as a
parser, not as an output generator, and does not support the expressive
power of parsing expression grammars (PEGs), but rather implements a
C-like structure model enhanced with length fields and constraints.
PacketTypes also cannot handle complicated encodings such as compressed
data, which are supported by Nail's stream transforms.

Parser generators for binary protocols were first introduced by the
Hammer~\cite{hammer-parser} parser.
While previous parser generators could also be used to write grammars
for binary protocols,\footnote{Theoretically speaking, the alphabet
over which a grammar is an abstract set, so most algorithms work
just as well on an alphabet of $\{0,1\}$.} doing so is practically
inconvenient. Hammer allows the programmer to specify a grammar in
terms of bits and bytes instead of characters. Common concerns, such as
endianness and bit-packing are handled transparently. 

Hammer implements grammars as language-integrated parser combinators, an approach popularized by
Parsec for Haskell~\cite{LeijenMeijer:parsec}. The parser combinator style (to our knowledge, first
described by Burge~\cite{burge1975recursive}) is a natural way of concisely expressing top-down
grammars~\cite{Danielsson:2010:TPC:1863543.1863585}
by composing them from one or multiple sub-parsers.\footnote{For more
background on the history of expressing grammars, see Bryan Ford's
masters thesis~\cite{ford2002packrat}, which also describes the
default parsing algorithm used by Hammer.}
Hammer then constructs a tree of function pointers which can be invoked to parse a given input into
an AST\@.

Nail improves upon Hammer in three ways.  First, Nail generates output in
addition to parsing input.  Second, Nail does not require the programmer
to write potentially insecure semantic actions.  Last, Nail's structural
dependencies and stream transforms allow it to work with protocols that
Hammer cannot handle, such as protocols with offset fields, length fields,
checksums, or compressed data, although Hammer has special facilities for
arrays immediately preceded by their length.

Parsifal~\cite{ANSSI:parsifal} is a parser framework that also supports
generating output for OCaml.  Parsifal structures grammars as an OCaml
type that holds an internal model and functions for parsing input and
output.  However, their generator can produce parsers and generators
only for simple, fixed-size structures.  The programmer can then use
these when implementing parsers and generators for more complicated
formats, manually handling offsets, checksums, and the like, risking bugs.
Nail handles more complicated constructs without the programmer manually
writing code to support them.

We presented an earlier design of Nail at a
workshop~\cite{bangert:nail-langsec-anon}.  At that stage, Nail had only
limited support for dependent fields, and did not support stream
transforms at all, which are crucial for supporting real-world formats
like DNS and ZIP\@.  The workshop paper also did not provide a detailed
design discussion or evaluation.


\paragraph{Application use of parsers.}

Generated parsers have long been used to parse human input, such
as programming languages and configuration files. Frequently, such
languages are often specified with a formal grammar in an executable
form. Unfortunately, parser frameworks are seldom used to recognize
machine-created input; as we demonstrate in \S\ref{s:eval},
state-of-the-art parser generators are not suitable for parsing or
generating many real-world data formats.

A notable exception is the Mongrel web server~\cite{mongrel} which
uses a grammar for HTTP written in the Ragel regular expression
language~\cite{ragel-paper}.  Mongrel was re-written from scratch
multiple times to achieve better scalability and design, yet the
grammar was reused across all iterations~\cite{patterson-citation}.
We hope that Nail's ideas make it possible to handle a wider range of
protocols using parser generators, and to build more applications on
top of grammar-based parsers.


