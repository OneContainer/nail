
* Do practical grammars require transformations? 
  Not all protocols require transformations. We used the Ethernet stack as an example of a protocol
  that is commonly not specified with a grammar, but can be handled with Nail without
  transformations. 

* Do transformations compromise the security guarantees of the parser?

  Transformations are security critical, but we believe it's much better
  than trusting an entire hand-written parser, for three reasons:

  1. Transformations are much smaller than an entire hand-written parser.
     For example, our Zip transformations are 78 lines of code, compared
     to 1600 lines of code for an entire parser.

  2. There are many common transformations that can be shared between
     grammars, and that come with Nail in a standard library.  For
     example, the entire UDP stack, which uses checksum and length
     field transformations, does not use any custom-written transformations
     of its own; the checksum and length transforms are part of Nail's
     standard transform library (which is used by DNS and ZIP as well).

  3. The code for transformations involves fewer tricky aspects than
     writing a parser, in the following ways:

     a. Nail provides convenient and safe interfaces for accessing streams,
        safely allocating memory, etc.

     b. If the transformation requires dependent variables (e.g., a length
        field or the ZIP compression method), Nail parses and validates
        those fields, and passes the result to the transformation function.

     As a result, writing transformation functions is less error-prone
     than writing a parser.

* How can Nail be integrated into deployed software?

Nail and all examples have been released as open source a while ago. We did not provide a link to
maintain reviewer blindness. We are talking with the Tor developers to replace their hand-written
Protocol implementation with Nail-generated code. Furthermore, our example DNS server implements
enough features to work as a typical authoritative name server (the glue records omitted
are only necessary to avoid circular dependencies when delegating name servers in certain
conditions. A typical website domain does not need them).

* How does the user program interact with Nail?

 The programmer can either provide a pointer to an in-memory buffer or provide a stream
 implementation (methods for reading, writing and repositioning). Nail then provides functions that
 turn a stream into an object and vice versa. Our benchmarks use memory buffers for network
 protocols and memory-mapped files for the ZIP archiver. For debugging, an error message mode can be
 turned on in which Nail will report which rules failed or succeeded apply at what position in the
 stream. However, in production code, all error handling is explicitly disabled and Nail returns
 either a valid object or nothing at all, so that programs do not partially process invalid inputs.
 A detailed argument for this approach can be found in [4].
 

* Is Nail systems research?
We believe Nail provides interesting systems insights, such as transformations, which provide a
pragmatic way of side-stepping the limited language our parsing algorithm understands. Related work
has appeared at systems conferences, e.g. PacketTypes at SIGCOMM. 
