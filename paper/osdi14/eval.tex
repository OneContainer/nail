\section{Evaluation}
\label{s:eval}
\input{fig-ethernet}
\input{fig-dnsfull}
\input{fig-zip}
In our preliminary evaluation of Nail, we try to answer four questions:

\begin{itemize}
\item Can Nail grammars support real-world data formats?
\item How much programmer effort is required to build an
      application that uses Nail for data input and output?
\item Do applications handling input and output with Nail suffer from less security vulnerabilities?
\item How fast are systems using Nail parsers as opposed to hand-written input handling? 
\end{itemize}

\subsection{Data formats.}
\label{s:eval-formats}
To answer the first question, we implemented grammars for four protocols with particularly
challenging features and show that Nail is a good fit for these data formats. In
\S\ref{s:eval-effort} we will demonstrate that Nail is easier to use than hand-written parsers and
more convenient than state-of-the-art parser generators for formats that they can handle.

In particular, we show extracts from grammars for the following protocols: 
\begin{itemize}
\item A subset of Ethernet network packets, containing ARP, ICMP and UDP/IP packets. See Figure~\ref{fig:ethernet-extract}.
\item DNS packets as described in RFC 1035, featuring label compression. See Figure~\ref{fig:dns-full}.
\item ZIP files, with compression, check-sums and a complicated procedure to identify the header.
  See Figure~\ref{fig:zip-extract}.
\end{itemize}




one for  DNS queries and respones, as per RFC1035 (shown in, one for the ZIP
archive format and a grammar for Ethernet frames containing ARP, ICMP and UDP packets. We also
parse Nail grammars with Nail, demonstrating that our system can also handle text-based protocols
and languages.  

The results suggest that Nail is a good fit for these data formats. 



\subsection{Programmer effort.}
\label{s:eval-effort}
To answer the second question, we implemented small example applications based on the above
grammars and compared code size with comparable applications written without parser generators. We
also compare our DNS implementation to the example DNS application provided with the Hammer parser generator.



 a functioning toy DNS
server.  In particular, we cloned the test DNS server from the Hammer
distribution to Nail.  Hammer ships with a toy DNS server written in 683
lines of code, excluding the Hammer framework itself, that responds to
any valid DNS query with a CNAME record to the domain ``spargelze.it''.
Most of this code is taken up with custom validators, semantic actions,
and data structure definitions, with only 52 lines of code defining the
grammar with Hammer's combinators.

Our DNS server consists of 148 lines of C code and 48 lines of Nail
grammar, and supports a custom zone file format with A, NS, MX, and
CNAME records. The same grammar is used, together with 98 lines of C,
to implement a functional toy clone of the \texttt{host} command-line
tool. However, because our grammar does not yet support DNS label
compression, the latter tool will occasionally reject valid real-world
DNS responses. Both clients have functional anti-spoofing measures.

It is hard to compare the programming effort required to implement
our toy DNS server to that of a real world DNS server, since
we have less functionality, in particular for DNS compression
and additional hint records that real-world DNS servers send.
However, the closest in functionality and intent is Dan Bernstein's
djbdns,\footnote{\url{http://cr.yp.to/djbdns.html}} which aims to be
a minimalist, highly secure DNS server. The latest release of djbdns,
including various support tools, is about 10,000 lines of C as measured by
\texttt{sloccount}.  We expect that it is possible to build a feature-par
version with Nail that is an order of magnitude smaller and intend to
do so.

\paragraph{Security} 
 
\paragraph{Other issues.}

As Nail is work in progress, many parts of the implementation, syntax and
design are not complete yet and we do not yet have meaningful performance
or security metrics.

