===========================================================================
                           OSDI '14 Review #140A
                     Updated 4 Jun 2014 3:33:01pm PDT
---------------------------------------------------------------------------
  Paper #140: Nail: A practical tool for parsing and generating data
              formats
---------------------------------------------------------------------------

                      Overall merit: 4. Weak accept

                         ===== Paper summary =====

This paper proposes a tool that simplifies the creation of "correct and secure" parsers for file formats and communication protocols. The key idea is to define a grammar that lets programmers define a parser and automatically generate both the data format in the actual file or packet data as well as the internal data-structures used by the application to represent the corresponding data --- without having the programmer write actions to build the data-structures in memory. Guaranteeing that equivalence leads to more secure implementation.

                      ===== Comments for author =====

I enjoyed reading this paper. I especially liked that the evaluation explored well defined questions. I suggest though that the authors improve the motivation by giving more information and more emphasis on the non-memory security bugs, since those are much more likely to be addressed by other tools/analysis or by using  a different programming language. 

A few comments to help presentation:

* The paper makes some noise about "semantic bisection" early on but then kind of abandons that. I get it that this is important to improve security properties of the implementation, but the text does not discuss that clearly and I think that is important to make the case cleanly. 

* If I understood correctly, pretty much all useful parsers will need "transformations", which involve arbitrary code. Wouldn't that compromise the security properties?

             ===== Questions to address in the response =====

Can you comment on whether the arbitrary code in the  "transformations" can compromise the security properties of the resulting parser?

===========================================================================
                           OSDI '14 Review #140B
                     Updated 8 Jun 2014 8:18:04pm PDT
---------------------------------------------------------------------------
  Paper #140: Nail: A practical tool for parsing and generating data
              formats
---------------------------------------------------------------------------

                      Overall merit: 4. Weak accept

                         ===== Paper summary =====

This paper describes Nail, a tool for automatically creating parsers
and generators for data formats based upon a custom specification
language.  Nail improves upon previous approaches by using a single
specification to generate both parsers and generators (most previous
work focuses just on the parsing half), and for developing two
mechanisms to deal with thorny aspects of data formats (e.g.,
dependent variables like lengths and checksums).  The paper applies
Nail to two challenging data formats, DNS and zip, to demonstrate that
it can handle complex applications in practice.

                      ===== Comments for author =====

I enjoyed the paper and I find the general argument of using tools to
generate code to reduce bugs and security vulnerabilities an appealing
one.  However, I am not that familiar with the details of the previous
work in the area or the programming language techniques employed in
Nail.  The paper is well written and speaks with authority.  So I am
generally positive about the paper, but temper it since I'm hardly an
expert.

Taking the benefits of Nail at face value, then the key challenge
facing tools like Nail is adoption.  The compelling argument for a
tool like Nail is fewer bugs and improved security.  The only way such
claims are going to be proved is for Nail to be used in practice in
generating code that gets deployed and is the focus of attacks.  So
how do you get tools like Nail to be used in deployed code?  Both the
DNS and zip implementations generated by Nail are functional, but fall
short of a full implementation.  What would it take to integrate
Nail's implementation into standard tools?  If the gaps are not
fundamental to the approach, then how much work remains?

Along those lines, are you going to make Nail available for download?
If someone wanted to use Nail in an implementation, could they?

Section 4.1: "Therefore, Nail introduces transformations, which allow
arbitrary code by the programmer to interact with the parser and
generator."  If I were to attack software that used Nail,
transformations would be the first place I would start: if there are
weaknesses in the implementation, they would likely be here.  Are
there additional constraints that transformations word under that make
them easier to implement and thereby reduce the probability of
vulnerabilities?  Or can the only argument that be made is that Nail
reduces the amount of code that is manually generated to just
transformations?

Similarly Section 4.4: "This transformation must be carefully written
to not have bugs."  Doesn't that go without saying for any code that
can be potentially attacked?

Section 6.1: You are now experts on real-world data formats and the
headaches they create for tools to deal with them automatically.
Since there will undoubtedly be new formats defined in the future, do
you have any best-practice guidelines or recommendations you can give
to format/protocol designers, or at least practices to avoid?

Section 6.3: It is difficult to evaluate the improved security that
Nail should provide, and you do what you can in arguing that Nail
implementations do not suffer from previous vulnerabilities.  But if
you release Nail, or even just your DNS and zip implementations,
you'll take a big step forward in terms of arguing the benefits of
Nail itself and automated parser/generator creation in general.  It
would be great to hand Nail and its DNS and zip to a grad security
course and have them hammer on it and try to break it.

             ===== Questions to address in the response =====

How do you go from Nail-generated prototypes to integrating
Nail-generated code into deployed software?

===========================================================================
                           OSDI '14 Review #140C
                     Updated 13 Jun 2014 7:03:22pm PDT
---------------------------------------------------------------------------
  Paper #140: Nail: A practical tool for parsing and generating data
              formats
---------------------------------------------------------------------------

                      Overall merit: 5. Accept

                      ===== Comments for author =====

Ugh - I'm late on my reviews and apologize.  I will update this but don't want to slow things down.

I quite liked this.  Solves a reasonable problem, well motivated by contemporary security problems arising from real-world parsing problems, and has been applied to three different and non-trivial examples to good effect.  I have no real complaints about this work, only a few little quibbles and concerns.  Accept!

===========================================================================
                           OSDI '14 Review #140D
                     Updated 2 Jul 2014 11:50:10pm PDT
---------------------------------------------------------------------------
  Paper #140: Nail: A practical tool for parsing and generating data
              formats
---------------------------------------------------------------------------

                      Overall merit: 2. Reject

                         ===== Paper summary =====

Nail is a tool for generating both parsers and generators for a wide
variety of binary data formats.  The motivation for Nail is that such
parsers tend to be a source of security holes, especially because the
grammar and internal object model are usually decoupled; Nail couples
them so that the programmer doesn’t have to think about things twice.
Nail also has explicit mechanisms for handling tricky issues such as
length fields, offsets, etc.

                      ===== Comments for author =====

Well-motivated problem.  Possibly(*) a nice design.  Wrong conference.

(*) “possibly” because I’m a reviewer for an OS conference, and I don’t
know enough about the existing literature for PL and security fields to
have a clear idea about the novelty or soundness of this work.

Anyway: some additional comments:

(1) the paper makes a big deal about the coupling of grammar and
internal data structure, but it never really exposes what a Nail-generated
internal data structure looks like — just a bunch of pieces of it.

(2)  Also, the grammar for Nail itself is only partially described, mostly by example;
e.g., page 7 describes the “Wrap combinator” but one has to read line 39
of figure 2 to infer that this is what the < > notation is used for.

(3) Nail provides security until it does’t (cf. the statement on p 8
that “This transformation must be carefully written not to have bugs.”
kind of a true statement for any piece of code, right?)

(4) The grammar seems somewhat jacky to me … maybe I don’t know enough
about fancy grammars (but then, hey, wrong conference!)

(5) The paper repeatedly claims that the Nail-based DNS server is faster
than BIND … and then in the last paragraph (before Conclusion) it admits
that BIND does a load of other things.  So: not an apples-to-apples
comparison, but someone reading just the abstract or introduction wouldn’t
necessarily realize that.

(6) The paper sometimes uses jargon that not everyone could be expected
to know.  E.g., I realized what “ROP-attacks” means, because I’ve read
papers about return-oriented programming … but the paper doesn’t define
this acronym (and why not cite a primary source, such as
http://cseweb.ucsd.edu/~hovav/dist/rop.pdf, rather than [4]?)

(7) I can see that DNS and ZIP parsers are tricky.  But the other
examples in figure 6 leave me feeling “what’s the big deal?”  Are
there lots of buggy UDP parsers out there?

===========================================================================
                           OSDI '14 Review #140E
                     Updated 7 Jul 2014 12:13:48am PDT
---------------------------------------------------------------------------
  Paper #140: Nail: A practical tool for parsing and generating data
              formats
---------------------------------------------------------------------------

                      Overall merit: 5. Accept

                         ===== Paper summary =====

This paper describes a parsing tool called Nail that uses a single grammar specification for parsing and to internally represent objects.

                      ===== Comments for author =====

Insecure parsing is an incredibly important problem that hasn't received enough attention from the research community (as far as I know). Nail seems like a great tool for improving the robustness of many systems.

Using the grammar to define a re-usable object representation is clever and powerful. 

The main technique that Nail uses to make parsing safe is to eliminate semantic actions. However, Nail transformations seem equally unsafe. The authors should do a better job clearly articulating why are transformations more trustworthy or less error prone than normal semantic action code. Is the argument for Nail’s better safety that there is less error prone code, that transformations are less error prone themselves, or a combination of the two?

Nail grammars are remarkably compact and easy to read.

Having said that, it was a little unclear how a programmer actually uses a Nail grammar. Since there are no semantic actions, at what point does user code execute (aside from transformations)? Does client code hand off a file descriptor with the input stream to a Nail library and receive an object representing the input in return. How does the program interact with the internal representation, especially since dependent fields are not exposed through the internal model?

How does error handling work? For example, can a programmer define a callback in case a network message is malformed? How much of the parsing context can be exposed to the error handler. This would be useful for logging information about bad input. 

Given that PDF parsing has caused so much trouble (at least on iOS), how hard would it be to write a PDF parser in Nail? Is there a reason why you haven’t done this yet?

Why is the Nail DNS server faster? Is it just because it does less or does Nail fundamentally reduce the amount of work a parser needs to do?

             ===== Questions to address in the response =====

How does user code interact with a Nail grammar and library?

