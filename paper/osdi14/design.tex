\section{Design}
\label{s:design}

Nail's goals are to reduce programmer effort required to safely interact
with data formats.  In particular, this means:

\begin{itemize}

\item Using the grammar to define both the \emph{external format}
      and the \emph{internal representation}.

\item Both parsing inputs into internal representations, as well as
      generating outputs from internal representations, without
      requiring the programmer to write any semantic actions.

\item Eliminating redundancy in internal representations, such as
      storing both an explicit length field and an implicit length
      of a container data structure, to provide programmers
      an unambiguous view of the data.

\item Allow programmers to define grammars for complex real-world
      data formats through well-defined extensibility mechanisms.

\end{itemize}

\subsection{Overview}

\paragraph{Internal model.}

Nail grammars describe both the \emph{external format} and an
\emph{internal representation} of a protocol, as opposed to existing
grammar languages, which describe only the former and leave it up to
the programmer to construct an internal representation, typically in
the form of an abstract syntax tree.
Nail produces the following from a single, descriptive grammar: 

\begin{CompactItemize}
\item \textit{type declarations} for the internal model,
\item the \textit{parser}, a function to parse a sequence of bytes into an
instance of the model, and
\item the \textit{generator}, a function to create a
sequence of bytes from an instance of the model.
\end{CompactItemize}

\noindent

\paragraph{Semantic bijection.}

In order to generate output, Nail maintains
a \emph{semantic bijection} between the external format and the internal model.
That is, when Nail parses an input into an internal representation, and then
generates output from that representation, the two byte streams (input and
output) will have the same meaning (i.e., be interpreted equivalently by Nail).
However, the byte streams might not be identical.
A bijection in the traditional sense often does not make sense for data
formats. Consider a grammar for a text language that tolerates white space, or a binary protocol
that tolerates arbitrarily long padding.
%\footnote{Say, the physical layer of most communication
%  protocols is a possibly infinite sequence of symbols that are syntactically nil followed by a
%  pre-determined synchronization sequence and the actual contents of the transmission.}
 Program semantics should be independent of the number of padding elements in the input, and Nail therefore
does not expose that information to the programmer. We call such discarded fields \emph{constants}.
Similarly, Nail does not preserve the layout of objects referred to by their offsets. If the grammar
consists of a simple protocol without offset fields, constants, and the like, there is a conventional
bijection between  internal models and valid parser inputs.

\paragraph{Hide redundant information.}
Nail's internal model is designed to hide unneeded and redundant information from the application.
Nail introduces \emph{dependent fields}, which contain data that can be computed during generation
and need to be kept as additional state during parsing. Dependent fields are, for example, used to represent
lengths, offsets, and checksums.

\paragraph{Parser extensions.}
Real-world protocols contain complicated ways of encoding data. Fully representing these in an
intentionally limited model such as our parser language is impractical. Therefore, Nail introduces
\emph{transformations}, which allow arbitrary code by the programmer to interact with the parser and
generator. Nail parsers and generators interact with data through an abstract stream, which allows
reading and writing of bits as re-positioning. Transformations allow the programmer to write
functions in a general purpose language that consume streams and define new temporary streams, while
also reading or writing the values of dependent fields.

Initial versions of Nail's design included a special combinator for handling offset fields,
which consumed a dependent field and applied
a parser at the offset specified therein. However, it proved impossible to foresee all the ways in which a protocol could encode an offset;
for example, some protocols such as PDF and ZIP locate structures by scanning for a magic number starting at the
end of the file or a fixed offset. In nested grammars, offsets are also not necessarily computed from
the beginning of a file or packet.
Nail's transformations allow the programmer to write arbitrary functions that can
handle such structures and streams, which are a generic abstraction for input and
output data that allow the decoded data to be integrated with the rest of the
generated Nail parser.


\input{fig-syntax}

\subsection{Basics}

A Nail parser defines both the structure of some external format and a data type to represent that
format. Parsers are constructed by combinators over simpler parsers, an approach popularized by the Parsec
framework~\cite{LeijenMeijer:parsec}. We provide the most common combinators familiar from other parser
 combinator libraries, such as Parsec and Hammer~\cite{hammer-parser} and extend them so they also
 describe a data type. 
Figure~\ref{fig:syntax} shows the elements of Nail grammars, which we describe in more detail below.

\paragraph{Integers and constraints.}

Nail's fundamental parsers represent signed or unsigned
integers with arbitrary lengths up to 64 bits, an
approach popularized by the Hammer framework~\cite{hammer-parser}.
Note that is possible to define parsers for sub-byte lengths, e.g.,
to parse the 4-bit
data offset within the TCP header.  The internal representation rounds up to the nearest integer
type; for example, a 24-bit unsigned integer will be stored in an unsigned 32-bit integer.

The grammar can also constrain the values of an integer.  Nail expresses
constraints as a set of permissible values or value ranges. Extending the Nail language and
implementation to support richer constraints languages would be relatively trivial, however we have
found that the current syntax covers permissible values within existing protocols correctly and
concisely.


\paragraph{Repetition.}

The \emph{many} combinator takes a parser and applies it repeatedly
until it fails, returning an array of the inner parser's results. The
\emph{sepBy} combinator
additionally takes a constant parser, which it applies in between parsing
two values, but not before parsing the first value or after parsing the
last.  This is useful for parsing an array of items delimited by a separator.
%For examle, \cc{many uint8} represents an array of 8-bit unsigned
%integers, and \cc{sepBy uint8=',' (many uint8 | '0'..'9')} recognizes
%comma-separated lists of decimal numbers.

\paragraph{Structures.}

% \begin{figure}[tb]
% \smaller[0.5]
% \begin{minipage}{0.45\columnwidth}
% \begin{verbatim}
% dns_header = {
%   id uint16
%   qr uint1
%   opcode uint4
%   aa uint1 
%   tc uint1
%   rd uint1
%   ra uint1
%   uint3 = 0
%   rcode uint4
% }
% \end{verbatim} 
% \end{minipage}
% ~
% \begin{minipage}{0.45\columnwidth}
% \begin{verbatim}
% struct dns_header {
%   uint16_t id;
%   uint8_t qr;
%   uint8_t opcode;
%   uint8_t aa;
%   uint8_t tc;
%   uint8_t rd;
%   uint8_t ra;
%   uint8_t rcode;
% };
% \end{verbatim} 
% \end{minipage}

% \caption{Nail grammar (left) and data model (right) for a part of the
% grammar for DNS packets.  The \cc{uint3 = 0} grammar represents
% 3 bits of padding (filled with zeroes).}
% \label{fig:dns-struct}
% \end{figure}


Nail provides a structure combinator with semantic labels instead of the sequence combinator that
other parser combinator libraries use to capture structures in data formats. 
The structure combinator consists of a sequence of fields, typically consisting of a label and a
parser that describes the contents of that field. Other field types will be described below.
 The syntax of the structure combinator is inspired by the Go language~\cite{golang}, with field names preceding their definition.
In our opinion, this syntax is easier to read than the widespread C-style structure and type
declarations.

% A sample grammar for a DNS header and the corresponding C data type the Nail parser produces, are
% shown in Figure~\ref{fig:dns-struct}.

\paragraph{Constants.}
In some cases, not all bytes in a structure actually contain information, such as magic numbers or
reserved fields. Those fields can be represented in Nail grammars by constant fields in structures.
Constant fields do not correspond to a field in the internal model, but they are validated during
parsing and generated during output.  Constants can either have integer values, such as
\cc{uint3 = 0} or string values for text-based protocols, e.g. \cc{many uint8 = ``Foo''}.

In some protocols, there might be many ways to represent the same constant field
and there is no semantic difference between the different syntactic representations.
Nail therefore allows repeated constants, such as \cc{many (uint8=' ')}, which parses any number of space characters, or
\cc{|| uint8 = 0x90 || uint16 = 0x1F0F}, which parses two of the many representations for x86
NOP instructions, which are used as padding between basic blocks in an executable. 

As discussed above, choosing to use these combinators on constant parsers
weakens the bijection between the format and the data type, as there are
multiple byte-strings that correspond to the same internal representation and
the generator chooses one of these.

\paragraph{Wrap combinator.} 
When implementing real protocols with Nail, we often found
structures that consist of many constants and only one named field. This pattern is
common in binary protocols which use fixed headers to denote the type of data
structure to be parsed.  In order to keep the internal representation cleaner,
we introduced the wrap combinator, which takes a sequence of parsers containing
exactly one non-constant parser. The parser and generator act as though the wrap
combinator was a sequence of parsers, but the data model does not wrap the
single value in another structure, making the application-visible representation
(and thus application code) more concise.
For example, \cc{<uint8='"'; many int8 | 'a'..'z'; uint8='"'>} parses a quoted
lowercase word into an array.

\paragraph{Choices.}
Our choice combinator takes multiple labeled parsers and tries each of them in turn, backtracking
to the initial position if an option fails. This behavior for the choice combinator, the defining
feature of Parser Expression Grammars~\cite{ford2002packrat}, resolves any ambiguities explicitly.
Internally, the choice combinator represents choices as tagged unions. 

If two options the same string could be parser by two options, generated output for the latter
option is not necessarily understood identically by the parser. However, actual data formats are
usually not ambiguous in this sense.
\XXX[nz][I don't understand this paragraph (esp the first sentence).]


\paragraph{Optional.}
Nail includes an \cc{optional} combinator, which attempts to recognize a value, but succeeds
without consuming input when it cannot recognize that value. Syntactically, \cc{optional} is
equivalent to a choice between the parser and an empty structure, but in the internal model it is
more concisely represented as a reference that is null when the parser fails.

\paragraph{Rules.}
A Nail grammar consists of rules that assign a parser to a name. Rules are written as
assignments, such as \cc{ints = many uint8}, which defines a rule called \cc{ints} with the
body \cc{many uint8}.  As we will describe in \S\ref{s:dependent}
and \S\ref{s:transforms}, rules can optionally consume parameters. 
Rules can be invoked in a Nail grammar anywhere a parser can appear. Rule invocations act as though
the body of the rule had been substituted in the code. If parameters appear, they are passed by reference.

\paragraph{References.}
Rules allow for recursive grammars. To support recursive data types, we allow introduce the
reference combinator \cc{*}  that does not change the syntax of the external format described, but
introduces a layer of indirection, such as a reference or pointer, to the model data type.
For example example,   balanced parentheses could be parsed as follows: \cc{paren = < uint8="("; optional *paren; uint8=")" >}.

\XXX[nz][Do you need \cc{*} here?  It seems like \cc{optional paren} would
already have a C representation of \cc{paren*} according to our big figure.]

% To support recursive structures, we include a reference combinator \cc{*}, which
%   is syntactically equivalent to directly including the parser, but in the internal model adds a
%   level of indirection to the value. This allows recursive structures to be parsed, f



\subsection{Dependent fields}
\label{s:dependent}
Data formats often contain values that are determined by other values or the layout of information,
such as checksums, duplicated information, or offset and  length fields.
We represent such values using \emph{dependent fields} and handle them transparently during
parsing and generation without exposing them to the internal model. 


Dependent fields are defined within a structure like normal fields, but their name starts with an \cc{@} symbol.
A dependent field is in scope and can be referred to by the definition of all subsequent fields in
the same structure. Dependent fields can be passed to rule invocations as parameters.

Dependent fields are parsed just like other fields in the external format, but they are not stored
in the internal data type. Instead, the parser stores the value in a
temporary location, so that the field can be referenced by subsequent parsers.

When generating output, Nail visits a dependent field twice. First, while generating the other fields of a
structure, the generator reserves space for the dependent field in the output. Once
the dependent field goes out of scope, the generator  writes the
dependent field's value to this space.

Nail provides only one built-in combinator that uses dependent fields, \cc{n_of}, which is used
for count fields. For example, DNS labels are encoded as Pascal-style strings: a length followed by
the value of the label. The Nail grammar for DNS labels can represent
this pattern as:

{
\smaller[0.5]
\begin{verbatim}
  {
    @length uint8 | 1..64
    label n_of @length uint8
  }
\end{verbatim}
}

Other dependencies, such as offset fields or checksums, are not handled directly by combinators, but
through  transformations, as we describe next.

\subsection{Input streams and transformations}
\label{s:transforms}

Traditional parsers handle input one symbol at a time, from beginning to end.
However, real-world formats often require non-linear parsing. Offset fields require a parser to move
to a different position in the input, possibly backwards. Size fields require the parser to stop
processing before the end of input has been reached, and perhaps resume executing a parent parser.
Other cases, such as compressed data, require more complicated processing on parts of the input
before it can be handled.

Nail introduces two concepts to handle this, \emph{streams} and \emph{transformations}. 
Streams represent a sequence of bytes that contain some external format. The parsers and generators
that Nail generates always operate on an implicit stream named \cc{\$current} that they process front to
back, reading input or appending output.
Grammars can use the \cc{apply} combinator to parse or generate external data on a different stream,
inserting the result in the data model.

Streams can be defined in two ways.
First, a rule can require streams as arguments, which can be passed in by the program that invokes
the generated parser. Every rule needs to be passed at least the implicit current stream.

Second, the programmer can create temporary streams in the grammar with \emph{transformations},
which are two arbitrary functions called during parsing and output generation respectively.
The parsing function  takes any number of stream arguments and dependent field values,
and produces any number of temporary streams. This function may reposition and read from the
input streams and read the values of dependent fields, but not change their contents and values. 
The generating function has to be an inverse of the parsing function. It takes the same number of
temporary streams that the parsing function produces, and writes the same number of streams and
dependent field values that the parsing function consumes.

Typically, the top level of most grammars is a rule that takes only a single stream, which may then
be broken up by various transformations and passed to sub-rules, which eventually parse various linear
fragment streams. Upon parsing, these fragment streams are generated and then combined by the
transforms.

The programmer has to guarantee memory safety and unambiguity of the stream transformations. To
reduce both programmer effort and the risk of unsafe operations, we provide implementations of
transformations for many common features, such as checksums, size, and offset fields. Furthermore,
we provide library functions that can be used to safely operate on streams, such as splitting and
concatenation. Nail implements streams as iterators, so they can share underlying buffers and can be
efficiently duplicated and split.

Transformations can handle a wide variety of patterns in data formats, including the following: 
\paragraph{Offsets.}
We provide a transformation for handling offset fields, which is invoked as follows:
\cc{\$fragment transform offset\_u32(\$current, \cc{@}offset)}. 
This transformation corresponds to two functions for parsing and
generation, as shown in Figure~\ref{fig:xform-sig}. It defines a new stream \cc{\$fragment} that can
be used to parse data at the offset contained in \cc{@offset}, by
using \cc{apply \$fragment some_parser}.

\begin{figure}[h]
\smaller[0.5]
\input{code/offset-xform}
\caption{Pseudocode for two functions that implement the offset transform.}
\label{fig:xform-sig}
\end{figure}


\paragraph{Sizes.}
A similar transformation handles size fields. Just like the offset transform, it takes two parameters, a
stream and a dependent field, but instead of returning the suffix of the current stream after an
offset, it returns a slice of the given size from the current stream starting at its current
position. When generating, it appends the fragment stream to the current stream and writes the size
of the fragment to the dependent field.

\paragraph{Compressed data.}
Encoded, compressed, or encrypted data can be handled transparently by writing a custom
transformation that transforms a coded stream into one that can be parsed by a Nail grammar and vice
versa. Usually, this involves calling an existing library.

\paragraph{Checksums.}
Checksums can be verified and computed in a transformation that takes a stream and a dependent
field. In some cases, a checksum is calculated over a buffer that contains the checksum itself, with
the checksum being set to some particular value. Because the functions implementing a transformation
are passed a pointer to any dependent fields, the checksum function can set the checksum's initial
value before calculating the checksum over the entire buffer, including the checksum.


\paragraph{}
A real-world example with many different transforms, used to support
the Zip file format, is described in \S\ref{s:eval-format-zip}.


% For example, we imagine the following grammar could be used to represent
% a sequence of bytes \texttt{data} followed by its CRC32 checksum:

% \begin{verbatim}
% data many uint8; @checksum uint32
% raw_depend @checksum data crc32
% \end{verbatim}

% \noindent
% where \texttt{crc32} is a function supplied by the application, with
% the following signature:

% \begin{verbatim}
% bool crc32(uint32_t *out, uint8_t *in);
% \end{verbatim}

% Because this feature compromises Nail's security guarantees, it should
% only be used in limited circumstances and with carefully prepared checksum
% functions.  This feature is not implemented in the current prototype.

