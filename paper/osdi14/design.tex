\section{Design}
\label{s:design}

\subsection{Goals}
\paragraph{Internal Model.}
Nail grammars describe both the \emph{external format} and an \emph{internal representation} of a
protocol, as opposed to existing grammar languages describe only the former and leave it up to the programmer to
construct an internal representation, typically in the form of an abstract syntax tree. 

Nail produces the following from a single, descriptive grammmar: 
\begin{itemize}
\item type declarations for the internal model,
\item the \textit{parser}, a function to parse a sequence of bytes into an
instance of the model, and
\item the \textit{generator}, a function to create a
sequence of bytes from an instance of the model.
\end{itemize}

\noindent

\paragraph{Semantic Bijecction.}
Second, this well-defined internal representation allows Nail to invert the
parser and generate output, while maintaining a \emph{semantic bijection}, that is, when generating
the corresponding output to a parser input, the two byte streams will have the same meaning, i.e. be
interpreted the same by Nail, but might not be identical.
A bijection in the traditional sense often does not make sense when parsing data formats. 
Consider a grammar for a text language that tolerates white space, or a binary protocol that tolerates
arbitrarily long padding.\footnote{Say, the physical layer of most communication
  protocols is a possibly infinite sequence of symbols that are syntactically
  nil followed by a pre-determined synchronization sequence and the actual
  contents of the transmission.} Program semantics should be
independent of the number of padding elements in the input, and Nail therefore
does not expose that information to the programmer. We call such discarded
fields \emph{constants}. 
Similarly, Nail does not preserve the layout of
objects referred to by their offsets. If the grammar consists of a simple protocol without offset
fields, constants and the like, there is a normal bijection between the internal model and valid
parser inputs.
\paragraph{Hide redundant information.}
Nail's internal model is designed to hide unneeded information from the application. The more
information Nail automatically deduces, the less the application can produce invalid data.
Therefore, Nail introduces \emph{dependent fields}, which contain data that can be computed during
generation and needs to be kept as additional state during parsing. 

\paragraph{Allow parser extension.}
Real-world protocols contain complicated ways of encoding data. Representing these in an
intentionally limited model such as our parser language is complicated. Therefore, Nail introduces
\emph{transformations}, which allow arbitrary code by the programmer to interact with the parser and
generator. Nail parsers and generators interact with data through an abstract stream, which allows
reading and writing of bits as re-positioning. Transformations allow the programmer to write
functions in a general purpose language that consume streams and define new temporary streams, while
also reading or writing the value of dependent fields.

Initial versions of Nail included an offset combinator, which consumed a dependent field and applied
a parser at the offset specified therein. However, it proved impossible to foresee all the ways in which a protocol could encode an offset, for example
some protocols such as PDF and ZIP locate structures by scanning for a magic number starting at the
end of the file or a fixed offset. In nested grammars, offsets are also not necessarily from
the beginning of a file or packet.

We will introduce transformations, which allow the programmer to write arbitrary functions that can
handle such structures and streams, which are a generic abstraction for input and output data that
allow the decoded data to be integrated with the rest of the generated Nail parser.

\XXX[In the rest of this section, we first present the design of the Nail language and then show how
Nail's features match these goals.]
\subsection{Basics}
Nail grammars are a set of rules. Each rule assigns a parser, which can be a reference to another
rule, a trivial parser describing an integer of a certain width or a combinator that combines
multiple parsers in some way. We provide the most common combinators familiar from other parser
combinator libraries, such as Parsec\cite{LeijenMeijer:parsec} and Hammer\cite{hammer-parser}.
However, we extend the sequence and choice combinators normally found in parser combinator libraries
with \emph{semantic labels} that name fields in the internal models. The syntax described by a Nail
grammar does not depend on these semantic labels.

\paragraph{Integers and Constraints}
\begin{figure}[tb]
\begin{tabular}{@{}ll@{}}
\toprule
\bf Syntax & \bf Semantics \\
\midrule
\cc{int32} & 32-bit signed integer \\
\multirow{2}{*}{\cc{uint4}}
  & 4-bit unsigned integer, \\
  & returned as an 8-bit value \\
\multirow{2}{*}{\cc{uint8 | 1..3}}
  & 8-bit unsigned integer, \\
  & $1\leq x \leq 3$ \\
\multirow{2}{*}{\cc{uint16 | [1,2]}}
  & unsigned 16-bit integer, \\
  & $x \in \{1,2\}$ \\
\multirow{2}{*}{\cc{int32 | [1,5..255,512]}}
  & signed 32 bit integer, \\
  & $x \in \{ 1, 512 \} \vee 5\leq x\leq 255$ \\
\bottomrule
\end{tabular}
\caption{Example Nail grammars for integer values.}
\label{fig:range}
\end{figure}

Nail's fundamental parsers recognise signed or unsigned with arbitrary lengths up to 64 bits, an
approach popularised by the Hammer framework.\cite{hammer-parser}  
Note that is possible to define parsers for sub-byte lengths, e.g. to parse the 4-bit
data offset within the TCP header.  In the internal representation, integer values are represented
by the nearest usable integer size, for example a 24-bit unsigned integer will be stored in an
unsigned 32-bit double word.

The grammar can also express a constraint on an integer field. The current version of Nail expresses
constraints as a set of permissible values or value ranges. Extending the Nail language and
implementation to support richer constraints languages would be relatively trivial, however we have
found that the current syntax covers permissible values within existing protocols correctly and
concisely.

Figure~\ref{fig:range} shows several examples.

\paragraph{Repetition.}

The \emph{many} combinator takes a parser and applies it repeatedly
until it fails, returning an array of the inner parsers results. The
\emph{sepBy} combinator
additionally takes a constant parser, which it applies in between parsing
two values, but not before parsing the first value or after parsing the
last.
For example, \cc{many uint8} represents an array of 8-bit unsigned
integers, and \cc{sepBy uint8=',' (many uint8 | '0'..'9')} recognizes
comma-separated lists of decimal numbers.

\paragraph{Structures.}

\begin{figure}[tb]
\smaller[0.5]
\begin{minipage}{0.45\columnwidth}
\begin{verbatim}
dns_header = {
  id uint16
  qr uint1
  opcode uint4
  aa uint1 
  tc uint1
  rd uint1
  ra uint1
  uint3 = 0
  rcode uint4
}
\end{verbatim} 
\end{minipage}
~
\begin{minipage}{0.45\columnwidth}
\begin{verbatim}
struct dns_header {
  uint16_t id;
  uint8_t qr;
  uint8_t opcode;
  uint8_t aa;
  uint8_t tc;
  uint8_t rd;
  uint8_t ra;
  uint8_t rcode;
};
\end{verbatim} 
\end{minipage}

\caption{Nail grammar (left) and data model (right) for a part of the
grammar for DNS packets.  The \cc{uint3 = 0} grammar represents
3 bits of padding (filled with zeroes).}
\label{fig:dns-struct}
\end{figure}


Nail provides a structure combinator with semantic labels instead of the sequence combinator that
other parser combinator libraries use to capture structures in data formats. 
The structure combinator consists of a sequence of fields, typically consisting of a label and a
parser that describes the contents of that field. Other field types will be described below.
 The syntax of the structure combinator is inspired by the Go language\cite{golang}, with field names preceding their definition.
In our opinion, this syntax is easier to read than the widespread C-style structure and type
declarations.

A sample grammar for a DNS header and the corresponding C data type the Nail parser produces, are
shown in Figure~\ref{fig:dns-struct}.

\paragraph{Constants.}
In some cases, not all bytes in a structure actually contain information, such as magic numbers or
reserved fields. Those fields can be represented in Nail grammars by constant fields in structures.
Constant fields do not correspond to a field in the internal model, but they are validated during
parsing and generated during output.  Constants can either have integer values, such as
\cc{uint3 = 0} or string values for text-based protocols, e.g. \cc{many uint8 = ``Foo''}.

In some protocols, there might be many ways to represent the same constant field
and there is no semantic difference between the different syntactic representations.
Nail therefore allows repeated constants, such as \cc{many (uint8=' ')}, which parses any number of space characters, or
\cc{|| uint8 = 0x90 || uint16 = 0x1F0F}, which parses two of the many representations for X86
NOP instructions, which are used as padding between basic blocks in an executable. 

As discussed above, choosing to use these combinators on constant parsers
removes the bijection between byte-strings and our data model, as there are
multiple byte-strings that correspond to the same internal data structure and
the generator has to choose one of these representations.
\paragraph{Wrap combinator.} 
When implementing real protocols with Nail, we often found that
structures that consist of many constant parsers and only one named field. This pattern is
common in binary protocols which use fixed headers to denote the type of data
structure to be parsed.  In order to keep the internal representation cleaner,
we introduced the wrap combinator, which takes a sequence of parsers containing
exactly one non-constant parser. The parser and generator act as though the wrap
combinator was a sequence of parsers, but the data model does not wrap the
single value in another structure, making the application-visible representation
(and thus application code) more concise.


For example, \cc{word=<uint8='"'; many int8 | 'a'..'z'; uint8='"'>} parses a quoted
lowercase word into an array.

\paragraph{References.}
To support recursive structures, we include a reference combinator \cc{*}, which is
syntactically equivalent to directly including the parser, but in the internal model adds a level of
indirection to the value. This allows recursive structures to be parsed, for example, balanced
parentheses could be parsed as follows: \cc{paren = < uint8 ="("; optional *paren ;uint8=")">}

\paragraph{Choices.}
Our choice combinator takes multiple labelled parsers and tries each of them in turn, backtracking
to the initial position if an option fails. This behaviour for the choice combinator, the defining
feature of Parser Expression Grammars\cite{ford2002packrat}, resolves any ambiguities explicitly.
Internally, the choice combinator represents choices as tagged unions. 

If two options the same string could be parser by two options, generated output for the latter
option is not necessarily understood identically by the parser. However, actual data formats are
usually not ambiguous in this sense.
For example, Figure~\ref{fig:choice} demonstrates a simple choice
combinator.

\begin{figure}[h!]
\smaller[0.5]
\begin{verbatim}
  choose {
    A = uint8 | 1..8
    B = uint16 | ..256
  }
\end{verbatim}
\caption{A simple choice combinator that parses either an 8-bit unsigned
integer with a value between 1 and 8 (option A), or a 16-bit unsigned
integer with a value of at most 256 (option B).}
\label{fig:choice}
\end{figure}

Nail also includes an \cc{optional} combinator, which attempts to recognise a value, but succeeds
without consuming input when it cannot recognise that value. Syntactically, \cc{optional} is
equivalent to a choice between the parser and an empty structure, but in the internal model it is
more concisely represented as a reference that is null when the parser fails.



\subsection{Dependent fields}

Data formats often contain values that are determined by other values or the layout of information,
such as checksums, duplicated information  or offset and  length fields.
We represent such as values with \emph{dependent fields} and handle them transparently during
parsing and generation without exposing them to the internal model. 


Dependent fields are defined within a structure like normal fields, but their name starts with an \@-sign. 
A dependent field is in scope and can be referred to by the definition of all subsequent fields in
the same structure. Dependency fields can be passed to rule invocations as parameters.

During parsing, dependent fields are parsed just like other fields, but instead of storing their
value in a structure that will be returned to the programmer, the parser stores the value in a
temporary location. Thereafter, the value can be referenced in the grammar. 

When generating output, Nail visits a dependent field twice. When generating the fields of a
structure, it will reserve space for the dependent field in the output, but not write a value. When
the dependent field goes out of scope, the generator will backtrack to this space and write the
dependent fields value.

Nail only provides one built-in combinator, \cc{n_of} that uses dependency fields, which is used
for count fields. For example, DNS labels are encoded as Pascal-style strings: a length followed by
the value of the label. The Nail grammar for DNS labels can represent
this pattern as follows:

{
\smaller[0.5]
\begin{verbatim}
  {
    @length uint8 | 1..64
    label n_of @length uint8
  }
\end{verbatim}
}

Other dependencies, such as offset fields or checksums are not handled directly by combinators, but
through  transformations.

\subsection{Input streams and Transformations.}

In order to handle complicated input functions, Nail allows the programmer to
break out of Nail's generated code in a controlled fashion, by manipulating dependent fields and
streams. 
By default, Nail implements streams with in-memory buffers, but the programmer can override this implementation.
While parsing or generating a Nail grammar, there is always an implicit \emph{current stream} and
referred to as \cc{\$current} in the Nail language.

The programmer can define additional streams by writing a \emph{transformation}, a pair of
functions, one that generates new streams from existing streams during parsing and one that
combines streams during output generation. Temporary streams follow the naming and
scoping convention of dependent fields, but their names start with a \$-sign. 


The parsing function of the transformation takes any number of streams, either temporary or the current,
and outputs any number of temporary streams. The parsing function may reposition and read from the
input streams and read the values of dependent fields, but not change their values. The generating
function has to be an inverse of the parsing function. It takes the same set of temporary streams
the parsing function returned and is supposed to change the values of the same set of values the
generating function produced.

The programmer has to guarantee memory safety and unambiguity of the stream transformations. To
reduce both programmer effort and the risk of unsafe operations, we provide implementations of
transformations for many common features, such as checksums and size and offset fields. Furthermore,
we provide library functions that can be used to safely operate on streams, such as splitting and
concatenation. Nail implements streams as iterators, so they can share underlying buffers and can be
efficiently duplicated and split.

Transformations can handle a wide variety of patterns in data formats, including the following: 
\paragraph{Offsets.}
We provide a transformation for handling offset fields that is invoked as follows:
\cc{\$fragment transform offset\_u32(\$file\_stream, \@offset)}. 
They are implemented by two functions, as shown in Figure~\ref{fig:xform-sig}.

\begin{figure}[h]
\smaller[0.5]
\input{code/offset-xform}
\caption{Pseudocode for two functions that implement the offset transform.}
\label{fig:xform-sig}
\end{figure}


\paragraph{Sizes.}
A similar transformation handles size fields. Just like the offset transform, it takes two parameters, a
stream and a dependent field, but instead of returning the suffix of the current stream after an
offset, it returns a slice of the given size from the current stream starting at its current
position. When generating, it appends the fragment stream to the current stream and writes the size
of the fragment to the dependent field.

\paragraph{Compressed data.}
Encoded, compressed or encrypted data can be handled transparently by writing a custom
transformation that transforms a coded stream into one that can be parsed by a Nail grammar and vice
versa. Usually, this involves calling an existing library.

\paragraph{Checksums.}
Checksums can be verified and computed in a transformation that takes a stream and a dependent
field. In some cases, a checksum is calculated over a buffer that contains the checksum itself, with
the checksum being set to some particular value. Because the functions implementing a transformation
are passed a pointer to any dependent fields, the checksum function can set the checksums initial
value before calculating the checksum over the entire buffer, including the checksum.


\noindent A real-world example with many different transforms is explained in Section~\ref{s:eval-format-zip}.
 

% For example, we imagine the following grammar could be used to represent
% a sequence of bytes \texttt{data} followed by its CRC32 checksum:

% \begin{verbatim}
% data many uint8; @checksum uint32
% raw_depend @checksum data crc32
% \end{verbatim}

% \noindent
% where \texttt{crc32} is a function supplied by the application, with
% the following signature:

% \begin{verbatim}
% bool crc32(uint32_t *out, uint8_t *in);
% \end{verbatim}

% Because this feature compromises Nail's security guarantees, it should
% only be used in limited circumstances and with carefully prepared checksum
% functions.  This feature is not implemented in the current prototype.

