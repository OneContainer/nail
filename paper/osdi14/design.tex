\section{Design}
\label{s:design}

\subsection{Overview}
 
Nail grammars describe both the \emph{external format} and an \emph{internal representation} of a
protocol. Typical grammar languages describe only the former and leave it up to the programmer to
construct an internal representation, typically in the form of an abstract syntax tree. 


Nail produces the following from a single, descriptive grammmar: 

\begin{itemize}
\item type declarations for the internal model,
\item the \textit{parser}, a function to parse a sequence of bytes into an
instance of the model, and
\item the \textit{generator}, a function to create a
sequence of bytes from an instance of the model.
\end{itemize}

\noindent
In the rest of this section, we present the design of the Nail language.

\subsection{Basics}
Nail grammars are a set of rules. Each rule assigns a parser, which can be a reference to another
rule, a trivial parser describing an integer of a certain width or a combinator that combines
multiple parsers in some way. We provide the most common combinators familiar from other parser
combinator libraries, such as Parsec\cite{LeijenMeijer:parsec} and Hammer\cite{hammer-parser}.
However, we extend the sequence and choice combinators normally found in parser combinator libraries
with \emph{semantic labels} that name fields in the internal models. The syntax described by a Nail
grammar does not depend on these semantic labels.

\paragraph{Integers and Constraints}
\begin{figure}[tb]
\begin{tabular}{ll}
\toprule
\bf Syntax & \bf Semantics \\
\midrule
\texttt{int32} & 32-bit signed integer \\
\multirow{2}{*}{\texttt{uint4}}
  & 4-bit unsigned integer, \\
  & returned as an 8-bit value \\
\multirow{2}{*}{\texttt{uint8 | 1..3}}
  & 8-bit unsigned integer, \\
  & $1\leq x \leq 3$ \\
\multirow{2}{*}{\texttt{uint16 | [1,2]}}
  & unsigned 16-bit integer, \\
  & $x \in \{1,2\}$ \\
\multirow{2}{*}{\texttt{int32 | [1,5..255,512]}}
  & signed 32 bit integer, \\
  & $x \in \{ 1, 512 \} \vee 5\leq x\leq 255$ \\
\bottomrule
\end{tabular}
\caption{Example Nail grammars for integer values.}
\label{fig:range}
\end{figure}

Nail's fundamental parsers recognise signed or unsigned with arbitrary lengths up to 64 bits, an
approach popularised by the Hammer framework.\cite{hammer-parser}  
Note that is possible to define parsers for sub-byte lengths, e.g. to parse the 4-bit
data offset within the TCP header.  In the internal representation, integer values are represented
by the nearest usable integer size, for example a 24-bit unsigned integer will be stored in an
unsigned 32-bit double word.

The grammar can also express a constraint on an integer field. The current version of Nail expresses
constraints as a set of permissible values or value ranges. Extending the Nail language and
implementation to support richer constraints languages would be relatively trivial, however we have
found that the current syntax covers permissible values within existing protocols correctly and
concisely.

Figure~\ref{fig:range} shows several examples.

\paragraph{S.}

The \emph{many} combinator takes a parser and applies it repeatedly
until it fails, returning an array of the inner parsers results. The
\emph{sepBy} combinator
additionally takes a constant parser, which it applies in between parsing
two values, but not before parsing the first value or after parsing the
last.
For example, \texttt{many uint8} represents an array of 8-bit unsigned
integers, and \texttt{sepBy uint8=',' (many uint8 | '0'..'9')} recognizes
comma-separated lists of decimal numbers.

\paragraph{Structures.}

\begin{figure}[tb]

\begin{minipage}{0.45\columnwidth}
\begin{verbatim}
dns_header = {
  id uint16
  qr uint1
  opcode uint4
  aa uint1 
  tc uint1
  rd uint1
  ra uint1
  uint3 = 0
  rcode uint4
}
\end{verbatim} 
\end{minipage}
~
\begin{minipage}{0.45\columnwidth}
\begin{verbatim}
struct dns_header {
  uint16_t id;
  uint8_t qr;
  uint8_t opcode;
  uint8_t aa;
  uint8_t tc;
  uint8_t rd;
  uint8_t ra;
  uint8_t rcode;
};
\end{verbatim} 
\end{minipage}

\caption{Nail grammar (left) and data model (right) for a part of the
grammar for DNS packets.  The \texttt{uint3 = 0} grammar represents
3 bits of padding (filled with zeroes).}
\label{fig:dns-struct}
\end{figure}


Nail provides a structure combinator with semantic labels instead of the sequence combinator that
other parser combinator libraries use to capture structures in data formats. 
The structure combinator consists of a sequence of fields, typically consisting of a label and a
parser that describes the contents of that field. Other field types will be described below.
 The syntax of the structure combinator is inspired by the Go language\cite{golang}, with field names preceding their definition.
In our opinion, this syntax is easier to read than the widespread C-style structure and type
declarations.

A sample grammar for a DNS header and the corresponding C data type the Nail parser produces, are
shown in Figure~\ref{fig:dns-struct}.

\paragraph{Constants.}
In some cases, not all bytes in a structure actually contain information, such as magic numbers or
reserved fields. Those fields can be represented in Nail grammars by constant fields in structures.
Constant fields do not correspond to a field in the internal model, but they are validated during
parsing and generated during output.  Constants can either have integer values, such as
\texttt{uint3=0} or string values for text-based protocols, e.g. \texttt{many uint8 = ``Foo''}.

In some protocols, there might be many ways to represent the same constant field
and there is no semantic difference between the different syntactic representations.
Nail therefore allows repeated constants, such as \texttt{many (uint8=' ')}, which parses any number of space characters, or
\texttt{|| uint8 = 0x90 || uint16 = 0x1F0F}, which parses two of the many representations for X86
NOP instructions, which are used as padding between basic blocks in an executable. 

As discussed above, choosing to use these combinators on constant parsers
removes the bijection between byte-strings and our data model, as there are
multiple byte-strings that correspond to the same internal data structure and
the generator has to choose one of these representations.
\paragraph{Wrap combinator.} 
When implementing real protocols with Nail, we often found that
structures that consist of many constant parsers and only one named field. This pattern is
common in binary protocols which use fixed headers to denote the type of data
structure to be parsed.  In order to keep the internal representation cleaner,
we introduced the wrap combinator, which takes a sequence of parsers containing
exactly one non-constant parser. The parser and generator act as though the wrap
combinator was a sequence of parsers, but the data model does not wrap the
single value in another structure, making the application-visible representation
(and thus application code) more concise.


For example, \texttt{word= <uint8='"'; many int8 | 'a'..'z'; uint8='"'>} parses a quoted
lowercase word into an array.

\paragraph{References.}
To support recursive structures, we include a reference combinator \texttt{*}, which is
syntactically equivalent to directly including the parser, but in the internal model adds a level of
indirection to the value. This allows recursive structures to be parsed, for example, balanced
parentheses could be parsed as follows: \texttt{paren = < uint8 ="("; optional *paren ;uint8=")">}

\paragraph{Choices.}
Our choice combinator takes multiple labelled parsers and tries each of them in turn, backtracking
to the initial position if an option fails. This behaviour for the choice combinator, the defining
feature of Parser Expression Grammars\cite{ford2002packrat}, resolves any ambiguities explicitly.
Internally, the choice combinator represents choices as tagged unions. 

If two options the same string could be parser by two options, generated output for the latter
option is not necessarily understood identically by the parser. However, actual data formats are
usually not ambiguous in this sense. Figure~\ref{fig:choice} demonstrates a simple choice
combinator.

Nail also includes an \texttt{optional} combinator, which attempts to recognise a value, but succeeds
without consuming input when it cannot recognise that value. Syntactically, \texttt{optional} is
equivalent to a choice between the parser and an empty structure, but in the internal model it is
more concisely represented as a reference that is null when the parser fails.

\begin{figure}[tb]
\begin{verbatim}
choose {
  A = uint8 | 1..8
  B = uint16 | ..256
}
\end{verbatim}
\caption{A simple choice combinator that parses either an 8-bit unsigned
integer with a value between 1 and 8 (option A), or a 16-bit unsigned
integer with a value of at most 256 (option B).}
\label{fig:choice}
\end{figure}




\subsection{Dependent fields}

Data formats often contain values that are determined by other values or the layout of information,
such as checksums, duplicated information  or offset and  length fields.
We represent such as values with \emph{dependent fields} and handle them transparently during
parsing and generation without exposing them to the internal model. 


Dependent fields are defined within a structure like normal fields, but their name starts with an \@-sign. 
A dependent field is in scope and can be referred to by the definition of all subsequent fields in the same structure.

During parsing, dependent fields are parsed just like other fields, but instead of storing their
value in a structure that will be returned to the programmer, the parser stores the value in a
temporary location. Thereafter, the value can be referenced in the grammar. 

When generating output, Nail visits a dependent field twice. When generating the fields of a
structure, it will reserve space for the dependent field in the output, but not write a value. When
the dependent field goes out of scope, the generator will backtrack to this space and write the
dependent fields value.

Nail only provides one built-in combinator, \texttt{n_of} that uses dependency fields, which is used
for count fields. For example, DNS labels are encoded as Pascal-style strings - a length followed by
the value of the label. The Nail grammar for DNS packets in Figure~\ref{fig:dns-full} represents
this pattern as follows:

\begin{figure}[tb]
\begin{verbatim}
{ @length uint8 | 1..64
  label n_of @length uint8 }
\end{verbatim}
\caption{Nail grammar for uncompressed DNS labels.}
\end{figure}

Other dependencies, such as offset fields or checksums are not handled directly by combinators, but
through stream transformation.

\subsection{Input streams and Transformations.}


% Data formats often contain redundant information, such as checksums or duplicated values.
% Conventional parsers expose all this information and validate it manually, which can lead to bugs.

% Another problem for interface generators is that binary protocols often contain length and offset
% fields. Conventional parsing algorithms can, in principle, deal with bounded offset fields - a finite
% automaton can count a bounded integer, by introducing a state for each value. However, such grammars
% are very large, making the state-machine implementation inefficient and the grammar very complicated.

% Nail will properly support both offset and length fields and much of the
% following discussion applies to both, although the current prototype only
% implements lengths, which we will focus on.

% We call length or offset fields \textit{dependent fields}, because during
% parsing, another parser depends on them, and while generating output, their
% value depends on some other structure in the data model. Dependency fields
% appear in a structure combinator as would any other integer field, but
% their name begins with an \texttt{@} sign.  A dependency field has to
% appear in the grammar before it can be used.

% Dependency fields are not exposed in the data model, but instead are
% transparently computed.  This frees the developer from checking that
% these fields are correct (for input) or having to keep their values in
% sync with the rest of the data structure (for output).

% \paragraph{Length fields.}

% The length combinator, \texttt{n_of}, takes a dependency field $n$
% and a parser, evaluates the parser exactly $n$ times (i.e., setting
% the number of iterations to be the $n$ field's value), and returns
% an array of the parser's values. When generating output, it emits
% the array and writes its length to the dependency field.

% \paragraph{Offsets.}

% The \texttt{offset} combinator takes a dependency field and a parser. It
% moves the parser to the position specified in the offset field and
% invokes the inner parser, and then moves the input back to its original
% position.  While generating output, all structures referred to by offset
% are generated after the main structure and the dependent offset fields
% are patched up.

% \paragraph{Checksums.}

% In many data formats, some values depend on external representation,
% such as checksums and cryptographic signatures.  While it would be
% possible to extend our constraint language to be powerful enough to
% support such constructs, we would essentially be building a separate,
% Turing-complete language that has all the same pitfalls existing programs
% have.  Therefore, we intend to allow the programmer to carefully escape
% Nail's programming model and write a function that takes a pointer to
% the dependent value and a range of bytes, using the \texttt{raw_depend}
% combinator.

% For example, we imagine the following grammar could be used to represent
% a sequence of bytes \texttt{data} followed by its CRC32 checksum:

% \begin{verbatim}
% data many uint8; @checksum uint32
% raw_depend @checksum data crc32
% \end{verbatim}

% \noindent
% where \texttt{crc32} is a function supplied by the application, with
% the following signature:

% \begin{verbatim}
% bool crc32(uint32_t *out, uint8_t *in);
% \end{verbatim}

% Because this feature compromises Nail's security guarantees, it should
% only be used in limited circumstances and with carefully prepared checksum
% functions.  This feature is not implemented in the current prototype.

