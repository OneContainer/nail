\section{Motivation}
\label{s:motivation}

To motivate the need for Nail, this section presents a case study of
vulnerabilities due to ad-hoc input parsing and output generation.

The ZIP format has been associated with many vulnerabilities, and the
PROTOS Genome project found numerous security vulnerabilities in most
implementations of ZIP and other archive formats that are directly
related to input handling.
\XXX[what is the PROTOS Genome project?]

Between May 2011 and May 2014, the CVE database~\cite{cve-database} lists
83 vulnerabilities when searching for the string ``ZIP''. Of these, 42
were completely unrelated to the archive format, for example reporting
vulnerabilities revealing ZIP codes of other users. 26 vulnerabilities
were related to ZIP archives, but not to input processing, such as
trusting arbitrary update ZIP files sent to a server or vulnerabilities
that can be accessed through manipulating files in a ZIP container. This
includes several vulnerabilities allowing another files to replaced while
they are extracted from ZIP files because insufficiently secure temporary
directories are used. Of the 15 remaining vulnerabilities pertaining
to ZIP files, 14 vulnerabilities were related to input processing. The
other vulnerability, which falls outside of Nail's purview, concerns a
ZIP packer choosing a weak legacy cryptosystem even when configured to
use AES.

Out of the 14 input processing vulnerabilities, ten are memory corruption
attacks, that could also be avoided by using safer languages.  Most of
the buffer overflows seem to result from inconsistent offset fields
being manipulated without checking.

The remaining four vulnerabilities do not involve memory corruption,
but rather parser ambiguities.  Two of them relate to implementations
mis-parsing ZIP files, particularly in virus scanners.  One other
vulnerability is in a Python ZIP library, which uses both the size
field in the file entry and in the header, without checking for their
consistency.  This results in a denial-of-service through endless loops
or incorrectly extracted ZIP files.

A similar attack was used by the fourth vulnerability, the infamous
Android master key bug~\cite{saurik-masterkey} that completely
bypassed Android security through parser inconsistencies between the
ZIP handler that checks signatures for privileged applications and the
ZIP implementations that ultimately extract those files. Thus, valid
application bundles could be modified to include malicious applications
without breaking their signatures.



\paragraph{Vulnerability mitigation.}

Input processing vulnerabilities fall into two broad classes.  The first
class is memory safety bugs, such as buffer overflows, which allow an
adversary to corrupt the application's memory using specially crafted
inputs.  These mistakes arise in lower-level languages that do not
provide memory safety guarantees such as C, and can be partially
mitigated by a wide range of techniques, for example static analysis,
dynamic instrumentation, and address space layout randomization, that
make it more difficult for an adversary to exploit these bugs.
Nail helps developers of lower-level languages avoid these bugs
in the first place.

The second class is logic errors, where application code misinterprets
input data. Safe languages and exploit mitigation technologies do not
help against such vulnerabilities. This can lead to serious security
consequences when two systems disagree on the meaning of a network
packet or a signed message.  For example, the XNU kernel in iOS and the
user-mode code-signing verifier interpret executable metadata differently,
so the code signature sees different bytes at a virtual address than the
executable that runs~\cite{evaders6}.  Android's code signing system also
had a vulnerability due to parsing ambiguities~\cite{saurik-masterkey},
and parsing ambiguities even contributed to attacks on the X.509 protocol
underlying SSL~\cite{DBLP:conf/fc/KaminskyPS10}.  Logic errors can also
cause memory corruption bugs as well, for example when a protocol stores
the size of a buffer in two places and the implementation does not check
their consistency. These mistakes are highly application-specific, and
are difficult to mitigate using existing techniques, and these mistakes
can occur even in high-level languages that guarantee memory safety. By
allowing developers to specify their data format just once, Nail avoids
logic errors and inconsistencies in parsing and output generation.

% A subclass of logic errors are so-called \textit{weird machines}, where
% implementation side effects or under-specified parser behavior leads to a
% protocol or data format inadvertently becoming a Turing-complete execution
% environment, even though the original grammar did not require it.
% Frequently, this execution environment can either
% then directly manipulate data in unwanted ways or be used to make
% exploiting another bug feasible.\footnote{For example, by compiling a
% return-oriented-programming exploit from code fragments discoverepd on
% the fly.} Examples include x86 page tables~\cite{bangert2013page}, and
% ELF symbols and relocations~\cite{shapiro2013weird}. In the offensive
% research community, this has been generalized into treating a program
% as a \textit{weird machine}~\cite{bratus2011exploit} that operates on
% an input, analogous to a virtual machine operating on bytecode.
% Nail avoids these problems by having the parser precisely match the
% specified grammar, eliminating under-specified behavior.

% With currently prevalent software design methods, it is hard to isolate
% input-handling code from the rest of the program, as user input is
% typically passed through the program and processed in bits and pieces as a
% ``shotgun parser''~\cite{shotgun-parser}. Thus, partially invalid input might be partly 
% processed by the program until the invalid sections are encountered.


% Proper input recognition has been shown to be an excellent way of
% eliminating ambiguous inputs.  In one case, a PDF parser (implemented
% in Coq) was used to reject over $95\%$ of known malicious PDFs by checking
% whether they conform to the PDF format~\cite{Bogk-PDF}. The same project
% also produced a ``counter-example'' PDF that triggered numerous bugs
% in other PDF parsers. However, manually writing parser code and proving
% unambiguity does not scale to the number of file formats and protocols
% in existence and might result in parser code tied to one specific
% application. By supporting a wide range of real-world file formats,
% Nail helps programmers produce precise parsers for complex grammars.

%%This is supposed to go into design
% While it is possible to express short transformations on the input
% entirely as semantic actions\footnote{This is in fact the design
% rationale, to perform computation on the fly as the parser walks the
% parse tree.}, more complicated programs usually construct an internal
% representation, which contains all relevant information from the input
% in a format native to the programming language used. For example, a C
% programmer ideally wants to deal with structs and NULL-terminated arrays,
% whereas a C++ programmer might expect STL containers, a Java programmer
% interfaces, a Haskell programmer records and a LISP programmer property
% lists.  The structure of this internal representation usually resembles
% the structure of the grammar.

