\section{Motivation}
\label{s:motivation}

\paragraph{Vulnerability mitigation.}

Input processing vulnerabilities fall into two broad classes.  The first
class is memory safety bugs, such as buffer overflows, which allow an
adversary to corrupt the application's memory using specially crafted
inputs.  These mistakes arise in lower-level languages that do not
provide memory safety guarantees such as C, and can be partially
mitigated by a wide range of techniques, for example static analysis,
dynamic instrumentation, and address space layout randomization, that
make it more difficult for an adversary to exploit these bugs.
Nail helps developers of lower-level languages avoid these bugs
in the first place.

The second class is logic errors, where application code misinterprets
input data. Safe languages and exploit mitigation technologies do not
help against such vulnerabilities. This can lead to serious security
consequences when two systems disagree on the meaning of a network
packet or a signed message.  For example, the XNU kernel in iOS and the
user-mode code-signing verifier interpret executable metadata differently,
so the code signature sees different bytes at a virtual address than the
executable that runs~\cite{evaders6}.  Android's code signing system also
had a vulnerability due to parsing ambiguities~\cite{saurik-masterkey},
and parsing ambiguities even contributed to attacks on the X.509 protocol
underlying SSL~\cite{DBLP:conf/fc/KaminskyPS10}.  Logic errors can also
cause memory corruption bugs as well, for example when a protocol stores
the size of a buffer in two places and the implementation does not check
their consistency. These mistakes are highly application-specific, and
are difficult to mitigate using existing techniques, and these mistakes
can occur even in high-level languages that guarantee memory safety. By
allowing developers to specify their data format just once, Nail avoids
logic errors and inconsistencies in parsing and output generation.

% A subclass of logic errors are so-called \textit{weird machines}, where
% implementation side effects or under-specified parser behavior leads to a
% protocol or data format inadvertently becoming a Turing-complete execution
% environment, even though the original grammar did not require it.
% Frequently, this execution environment can either
% then directly manipulate data in unwanted ways or be used to make
% exploiting another bug feasible.\footnote{For example, by compiling a
% return-oriented-programming exploit from code fragments discoverepd on
% the fly.} Examples include x86 page tables~\cite{bangert2013page}, and
% ELF symbols and relocations~\cite{shapiro2013weird}. In the offensive
% research community, this has been generalized into treating a program
% as a \textit{weird machine}~\cite{bratus2011exploit} that operates on
% an input, analogous to a virtual machine operating on bytecode.
% Nail avoids these problems by having the parser precisely match the
% specified grammar, eliminating under-specified behavior.

% With currently prevalent software design methods, it is hard to isolate
% input-handling code from the rest of the program, as user input is
% typically passed through the program and processed in bits and pieces as a
% ``shotgun parser''~\cite{shotgun-parser}. Thus, partially invalid input might be partly 
% processed by the program until the invalid sections are encountered.


Proper input recognition has been shown to be an excellent way of
eliminating ambiguous inputs.  In one case, a PDF parser (implemented
in Coq) was used to reject over $95\%$ of known malicious PDFs by checking
whether they conform to the PDF format~\cite{Bogk-PDF}. The same project
also produced a ``counter-example'' PDF that triggered numerous bugs
in other PDF parsers. However, manually writing parser code and proving
unambiguity does not scale to the number of file formats and protocols
in existence and might result in parser code tied to one specific
application. By supporting a wide range of real-world file formats,
Nail helps programmers produce precise parsers for complex grammars.

%%This is supposed to go into design
% While it is possible to express short transformations on the input
% entirely as semantic actions\footnote{This is in fact the design
% rationale, to perform computation on the fly as the parser walks the
% parse tree.}, more complicated programs usually construct an internal
% representation, which contains all relevant information from the input
% in a format native to the programming language used. For example, a C
% programmer ideally wants to deal with structs and NULL-terminated arrays,
% whereas a C++ programmer might expect STL containers, a Java programmer
% interfaces, a Haskell programmer records and a LISP programmer property
% lists.  The structure of this internal representation usually resembles
% the structure of the grammar.

