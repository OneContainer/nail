\section{Introduction}

Code that handles untrusted inputs, such as processing network
data or parsing a file, is error-prone and is often exploited by
attackers.  This is in part because attackers have precise control
over the inputs to that code, and can craft inputs that trigger
subtle corner cases in input processing.  For example, the libpng
library has had 24 remotely exploitable vulnerabilities from 2007 to
2013,\footnote{\url{http://www.cvedetails.com/vulnerability-list/vendor_id-7294/Libpng.html}}
and Adobe's PDF and Flash viewers have been notoriously
plagued by input processing vulnerabilities.  Even relatively
simple formats, such as those used by the zlib compression
library, have had input processing vulnerabilities in the
past.\footnote{\url{http://www.cvedetails.com/vulnerability-list/vendor_id-72/product_id-1820/GNU-Zlib.html}}

A promising approach to avoid such vulnerabilities is to specify a
precise grammar for the input data format, and to use a parser generator,
such as {\tt lex} and {\tt yacc}, to synthesize the input processing
code.  Developers that use a parser generator will not need to write
error-prone input processing code on their own, and as long as the
parser generator is bug-free, the application will be safe from input
processing vulnerabilities.  Unfortunately, applying this approach in
practice, using state-of-the-art parser generators, requires addressing
several challenges.

First, parser generators typically parse inputs into an abstract syntax
tree (AST) that corresponds to the grammar.  In order to produce a data
structure that the rest of the application code can easily process,
application developers must write explicit {\em semantic actions} that
update the application's internal representation of the data based on
each AST node.  Writing these semantic actions by hand is error-prone,
much like other input processing code, and mistakes can result in memory
corruption bugs or misinterpreted inputs.



While it is possible to express short transformations on the input
entirely as semantic actions\footnote{This is in fact the design
rationale, to perform computation on the fly as the parser walks the
parse tree.}, more complicated programs usually construct an internal
representation, which contains all relevant information from the input
in a format native to the programming language used. For example, a C
programmer ideally wants to deal with structs and NULL-terminated arrays,
whereas a C++ programmer might expect STL containers, a Java programmer
interfaces, a Haskell programmer records and a LISP programmer property
lists.  The structure of this internal representation usually resembles
the structure of the grammar.

Therefore, a typical programmer has to describe the structure of his input
twice or even thrice to use a parser generator. Once, to write a grammar,
another time to write the semantic actions constructing his favourite
intermediate representation. In most languages the programmer also
has to write explicit type definitions, which describe the intermediate
object model again. Most programmers will baulk at this multiplication of
efforts and either hand-write a top-down parser which still eliminates
writing the semantic actions at the slight cost of verbosity or resort
to passing user input through their control flow, hopefully remembering
to verify each part before it is accessed.

A similar problem occurs when the programmer wants to generate output.
Even though not all programs may use the same format for output as they
do on input, different programs might use the same format for input and
output and re-using the same grammar is a good way to save engineering
effort and reduce parser differentials.  Some parser generators, e.g.
Boost.Spirit,\footnote{\url{http://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/index.html}}
allow the same grammar to be re-used for generating output from the
intermediate representation.  However, those generators require a new set
of semantic actions to be written, even though the relationship between
grammar and intermediate model was already expressed in the actions for
the parser.

