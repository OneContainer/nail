\section{Introduction}

Code that handles untrusted inputs, such as processing network
data or parsing a file, is error-prone and is often exploited by
attackers.  This is in part because attackers have precise control
over the inputs to that code, and can craft inputs that trigger
subtle corner cases in input processing.  For example, the libpng
library has had 24 remotely exploitable vulnerabilities from 2007 to
2013,\footnote{\url{http://www.cvedetails.com/vulnerability-list/vendor_id-7294/Libpng.html}}
and Adobe's PDF and Flash viewers have been notoriously
plagued by input processing vulnerabilities.  Even relatively
simple formats, such as those used by the zlib compression
library, have had input processing vulnerabilities in the
past.\footnote{\url{http://www.cvedetails.com/vulnerability-list/vendor_id-72/product_id-1820/GNU-Zlib.html}}

A promising approach to avoid such vulnerabilities is to specify a
precise grammar for the input data format, and to use a parser generator,
such as {\tt lex} and {\tt yacc}, to synthesize the input processing
code.  Developers that use a parser generator will not need to write
error-prone input processing code on their own, and as long as the
parser generator is bug-free, the application will be safe from input
processing vulnerabilities.  Unfortunately, applying this approach in
practice, using state-of-the-art parser generators, requires addressing
several challenges.

First, parser generators typically parse inputs into an abstract syntax
tree (AST) that corresponds to the grammar.  In order to produce a data
structure that the rest of the application code can easily process,
application developers must write explicit {\em semantic actions} that
update the application's internal representation of the data based on
each AST node.  Writing these semantic actions by hand is error-prone,
much like other input processing code, and mistakes can result in memory
corruption bugs or misinterpreted inputs.  Writing these semantic actions
also requires the programmer to describe the structure of the input three
times---once to describe the grammar, once to describe the internal data
structure, and once again in the semantic actions that translate the
grammar into the data structure---leading to another potential source
of bugs and inconsistencies.

A similar problem occurs when the programmer wants to generate output.
Even though not all programs may use the same format for output as they
do on input, different programs might use the same format for input and
output and re-using the same grammar is a good way to save engineering
effort and reduce parser differentials.  Some parser generators, e.g.
Boost.Spirit,\footnote{\url{http://www.boost.org/doc/libs/1_55_0/libs/spirit/doc/html/index.html}}
allow the same grammar to be re-used for generating output from the
intermediate representation.  However, those generators require a new set
of semantic actions to be written, even though the relationship between
grammar and intermediate model was already expressed in the actions for
the parser.

